---
title: "BFFとmicroservicesアーキテクチャ"
emoji: "🔗"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["GraphQL","Go", "Vue.js", "BFF", "microservices"]
published: false
---


## はじめに

sweeep CTOの平下です。先日CADDiさん主催のこちらで「BFFとmicroservicesアーキテクチャ」というテーマでLTさせていただきました。そのときのLT内容を記事にしました。

https://caddi.connpass.com/event/244672/

発表したスライドです。

https://speakerdeck.com/hirac1220/bfftomicroservicesakitekutiya

以下記事の内容です。
* BFFとmicroservicesアーキテクチャ採用の背景
* GraphQL/BFF導入のメリットと課題
* まとめと今後の課題


## BFFとmicroservicesアーキテクチャ採用の背景
### モノリスなアーキテクチャ
プロダクトローンチから3年経過し、技術負債がかなりたまっていました。

![](/images/7bd857ab904d66/old-archi.png)

モノリスなアーキテクチャには以下の課題がありました。
* モノリスなアーキテクチャを同時修正でコンフリ
* 単一DBでデータの肥大化。マイグレーションなど大変
* 凝集度が低く修正箇所漏れ

### microservicesアーキテクチャ
アーキテクチャーをmicroservicesアーキテクチャへ刷新しました。

![](/images/7bd857ab904d66/new-archi.png)

microservicesでモノリスなアーキテクチャの技術負債を以下のように解消しました。
* モノリスなアーキテクチャを同時修正でコンフリ
→　microservicesを少人数で各service修正
* 単一DBでデータの肥大化。マイグレーションなど大変
→　microservices毎にDBをもつ
* 凝集度が低く修正箇所漏れ
→　適切なドメインで凝集度上げる

### microservicesの課題
しかし、microservicesにも以下のような課題があります。
* 複数DBにおける情報の集約化
　ex. ：支払情報とユーザ情報など別DB
* 複数リソースにおけるFEの工数増・肥大化
　ex. ：上記支払情報にあるuser_idとユーザ情報を紐付け

そのため、以下のようにBFFで情報の集約と紐付けを実施し、GraphQLで集約した情報を返すようにしています。

![](/images/7bd857ab904d66/graphql.png)

また、情報取得と同様に、更新でも複数リソース同時更新のユースケースもあります。


## GraphQL/BFF導入のメリットと課題

### GraphQLメリット
GraphQLのメリットとして、以下のメリットがあります。
* スキーマ駆動 & mockで並行開発
* GraphQLスキーマからClient/Server生成
* クエリライクで複数リクエストなしに情報を取得できる


### スキーマ駆動 & mockで並行開発
スキーマ駆動開発で、定義ファイルからクライアントとサーバーのプログラムを自動生成したものを使用し、クライアントとサーバー間で齟齬が生じないようにしています。また、定義ファイルを元にMockを作成することで、サーバーの開発が終わっていなくてもクライアントがMockへアクセスし通信部分の開発や動作確認できるようにしています。

![](/images/5a181fce480191/schema.png)
### GraphQLスキーマからClient/Server生成
GraphQLスキーマからClientとサーバー（BFF）のプログラムを自動生成しています（以下はサンプル）。

* Client (TS) → client/model生成
```
$npm run graphql-codegen --config ./path/to/config.yml
```
* config.yml
```yml
/schema: http://localhost:3000/graphql
documents: ./src/**/*.graphql
generates:
  ./src/types.ts:
    plugins:
      - typescript
      - typescript-operations
```

* BFF (Go) → resolver/model生成
```
$go run github.com/99designs/gqlgen generate
```
* gqlgen.yml
```yml
schema: "*.graphql"
exec:
  filename: generated.go
model:
  filename: models_gen.go
resolver:
  type: Resolver
  layout: follow-schema
  dir: .
models:
...
```
### BFFメリット
* 各microservicesリソースをFEの必要な情報に束ねて返す
　ex.：BFFでUser情報 + 支払い情報を束ねる
　→ FEで情報の操作が必要ない
* EndpointがBFF一箇所で済む
　→ ない場合はBE (microservices）を意識する必要がある

### BFF無とBFF有の比較 (情報の集約)

![](/images/7bd857ab904d66/bff.png)

### BFF無とBFF有の比較 (Endpointの集約化)

![](/images/7bd857ab904d66/endpoint.png)

### GraphQLの課題
* GraphQL ↔ Protobufの値の詰め替えが発生
　Request： model.xxxInput → pb.xxxRequest
　Response：model.xxx ← pb.xxxResponse
　ex. ：    GraphQLではintしかサポートしていない
            Protobufだとint32/64
### GraphQL ↔ Protobufの値の詰め替え

![](/images/7bd857ab904d66/mapper.png)

### BFF課題
* BFF開発分の工数増・メンテ増
* ただmicroservices → BFF → FEと透過的に情報を渡して
　いるだけで冗長に感じることがある
* 反面、BFFでいろいろやらせる(=やらせたくなる)と
　Fatになるので気をつける

→ GraphQL Gateway (Apollo Federation)なども将来検討


## まとめと今後の課題

### まとめ：GraphQL & BFFメリット
* GraphQLはスキーマ駆動・情報の集約という点でメリット

* BFFはmicroservicesのEndpointの集約・仲介役でメリット

→ BFFを後から入れるのはインパクトが大きく
　(BFFの新規開発/Web & Mobile側の工数/インフラ etc…)
　最初に決断してよかった


後からBFF新規/Endpoint入替/情報集約... 

![](/images/7bd857ab904d66/implebff.png)


### 今後の課題
* BFF開発分の工数増で冗長に感じることも多いが、
　無いとFEで頑張らないといけなかったりする
　次のサービスではGraphQL Gatewayなど検討したい

* GraphQL & BFFは現在Web & Mobile共通のため、同時
　リリース。共通化やアジリティを下げない仕組みに課題

→ アーキテクチャにも「銀の弾丸」はないので改善し続ける


## おわりに
今回は

最後にフロントエンド・バックエンド・CoreAI機能開発のエンジニアを積極的に採用しています。ご興味のある方は下記リンクよりご応募お待ちしております！
https://www.wantedly.com/companies/sweeep/projects

または、まずはカジュアルにお話してみたい、という方は下記リンクよりお申し込みください！
https://meety.net/matches/rrjHPEVHXDiW
